---
title: "The Effect of Correlation Structure on Portfolio Optimisation Performance"
author: "Nathan Potgieter"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=10, fig.height=8, 
                      out.height='80%', out.width='80%', fig.align = 'center')
library("printr")
```

## Purpose

This document serves as the README for Nathan Potgieter's Stellenbosch University Masters thesis. This works sets out to perform Monte Carlo simulations of five different financial market types, each with a unique correlation structure, and then evaluate the performance of numerous portfolio optimisation routines in each market type. This is done in order to determine how a markets correlation structure impacts the performance of portfolio optimisers. Ideally a set of heuristics will be developed that can aid portfolio managers in their decision of which portfolio optimiser to use.

## Creating Correlation Structure Types

This section sets out to design five distinct 50 by 50 market correlation matrices, ranging from highly unrealistic, and purely theoretical, to more realistic hierarchically clustered matrices.
```{r markets, results='asis'}
# Loading required packages
library('pacman')
p_load(MCmarket, tidyverse, ggcorrplot)

#----------------------------------------------
# First look at the diagonal correlation matrix
# This seems far to simple and boring; Check with nico
#----------------------------------------------
corr_1 <- diag(50)
eigen_1 <- eigen(corr_1) # all eigenvalues are 1 and all eigenvectors contain only zero's
corr_1 %>% ggcorrplot(hc.order = TRUE, title = "Diagonal Matrix")

#---------------------------------------------
# Correlation matrix with no clusters
#---------------------------------------------
corr_2 <- gen_corr(D = 50, Clusters = "none")
eigen_2 <- eigen(corr_2)
corr_2 %>% ggcorrplot(title = "No Clusters")

#---------------------------------------------
# Correlation matrix with 5 clusters
#---------------------------------------------
corr_3 <- gen_corr(D = 50, Clusters = "non-overlapping", Num_Clusters = 5)
eigen_3 <- eigen(corr_3)
corr_3 %>% ggcorrplot(hc.order = TRUE, title = "Five Clusters")

#---------------------------------------------
# Correlation matrix with 10, 5 and 2 overlapping clusters
#---------------------------------------------
corr_4 <- gen_corr(D = 50, Clusters = "overlapping", Num_Clusters = c(10,5,2), Num_Layers = 3)
eigen_4 <- eigen(corr_4)
corr_4 %>% ggcorrplot(hc.order = TRUE, title = "Overlapping Clusters")

#-----------------------------------------------
# Some empirical correlation matrices - from S&P500
# See ??corr_mats for info on how dataset was compiled
# First looking at "normal market"
#-----------------------------------------------
corr_5 <- corr_mats$cor_normal[[2]]
eigen_5 <- eigen(corr_5)
corr_5 %>% ggcorrplot(hc.order = TRUE, title = "Normal Market") +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())

#----------------------------------------------
# "stressed market"
#----------------------------------------------
corr_6 <- corr_mats$cor_stressed[[1]]
eigen_6 <- eigen(corr_6)
corr_6 %>% ggcorrplot(hc.order = TRUE, title = "Stressed Market")  +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())

#----------------------------------------------
# "rally market"
#----------------------------------------------
corr_7 <- corr_mats$cor_rally[[1]]
eigen_7 <- eigen(corr_7)
corr_7 %>% ggcorrplot(hc.order = TRUE, title = "Rally Market")  +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())


#------------------------------------------
# Data set of eigenvalues
#------------------------------------------
eigens <- tibble(corr_1 = eigen_1$values,
                 corr_2 = eigen_2$values,
                 corr_3 = eigen_3$values,
                 corr_4 = eigen_4$values,
                 corr_5 = eigen_5$values,
                 corr_6 = eigen_6$values,
                 corr_7 = eigen_7$values)
stargazer::stargazer(eigens, type = "html", summary = FALSE, rownames = FALSE, out.header = FALSE)

```

## Simulating Markets

```{r monte carlo, eval=FALSE, include=TRUE}
pacman::p_load(MCmarket, tidyverse) 

# Setting number of markets and length of progress bar.
N <- 10000
pb <- dplyr::progress_estimated(N)


set.seed(9543712)
market_1 <-
  1:N %>% 
  map_dfr(~sim_market_with_progress(corr = corr_2,
                                    k = 252,
                                    mv_dist = "t",
                                    mv_df = 5,
                                    marginal_dist = "norm",
                                    marginal_dist_model = list(mu = 0, 
                                                               sd = 0.7),
                                    ts_model = NULL),
          .id = "Universe")
# Preliminary Save
save(market_1, file = "data/market_1.rda")

```

## Running Portfolio Optimisers

### Calculating Expected returns and Covarience matricies.

```{r portfoio optimisers}
pacman::p_load(lubridate, RiskPortfolios, fitHeavyTail)
load("data/market_1.rda")

data <- market_1 %>% 
  filter(Universe == 1) %>% 
  select(date, Asset, Return) %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date<first(date) %m+% days(100)) # only first 100 days

data_no_date <- data %>% select(-date) %>% data.matrix()

# Simple covariance matrix: Assuming Gaussian (when we know actually t)
cov <- RiskPortfolios::covEstimation(data_no_date)
# Ledoit Wolf shrinkage:
cov_lw <- RiskPortfolios::covEstimation(data_no_date, control = list(type = "lw"))
# Shrinkage using constant correlation matrix:
cov_const <- RiskPortfolios::covEstimation(data_no_date, control = list(type = "const"))
# FitHeavyTail method
HTT <- fitHeavyTail::fit_mvt(data_no_date)
mu_ht <- HTT$mu
cov_ht <- HTT$cov

cov %>% cov2cor() %>% ggcorrplot()
cov_lw %>% cov2cor() %>% ggcorrplot()
cov_const %>% cov2cor() %>% ggcorrplot() # this seems junk
cov_ht %>% cov2cor() %>% ggcorrplot()

Mu <- data %>%
  select(-date) %>% 
  data.matrix() %>% 
  RiskPortfolios::meanEstimation()

```

### Setting Constraints 


### Minimum Variance 
```{r Min Var}
pacman::p_load('NMOF', 'quadprog', 'tbl2xts')

minvar(var = cov_ht, wmin = 0.0, wmax = 0.3)

```

#### Min Var Portfolio Returns

```{r}
# Creating a single market dataset
data <- market_1 %>% 
  filter(Universe == 1) %>% 
  select(date, Asset, Return)  

# Creating a wide exante data set
data_exante <- data %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date<first(date) %m+% days(100))

# Calculating covarience matrix
cov <- data_exante %>% 
  select(-date) %>% 
  fit_mvt() %>% .$cov

# Calculating min var weights and 
weights <- 
  data %>% 
  filter(date == first(date)) %>% 
  mutate(weight = minvar(cov, wmin = 0, wmax = 1)) %>% 
  select(date, Asset, weight) %>% 
  tbl_xts(cols_to_xts = "weight", spread_by = "Asset")

# Creating expost portfolio dataset
data_expost_xts <- market_1 %>% 
  filter(Universe == 1) %>% 
  select(date, Asset, Return) %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date>first(date) %m+% days(100)) %>% 
  tbl_xts()


rmsfuns::Safe_Return.portfolio(data_expost_xts, weights = weights)
  
```

