---
title: "The Effect of Correlation Structure on Portfolio Optimisation Performance"
author: "Nathan Potgieter"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=10, fig.height=8, 
                      out.height='80%', out.width='80%', fig.align = 'center')
rm(list = ls())
gc()
```

## Purpose

This document serves as the README for Nathan Potgieter's Stellenbosch University Masters thesis. This works sets out to perform Monte Carlo simulations of five different financial market types, each with a unique correlation structure, and then evaluate the performance of numerous portfolio optimisation routines in each market type. This is done in order to determine how a markets correlation structure impacts the performance of portfolio optimisers. Ideally a set of heuristics will be developed that can aid portfolio managers in their decision of which portfolio optimiser to use.

## Creating Correlation Structure Types

### _ad hoc_

This section sets out to design five distinct 50 by 50 market correlation matrices, ranging from highly unrealistic, and purely theoretical, to more realistic hierarchically clustered matrices.
```{r making markets, results='asis'}
# Loading required packages
pacman::p_load(MCmarket, tidyverse, ggcorrplot)

#----------------------------------------------
# First look at the diagonal correlation matrix
# This seems far to simple and boring; Check with nico
#----------------------------------------------
corr_1 <- diag(50)
eigen_1 <- eigen(corr_1) # all eigenvalues are 1 and all eigenvectors contain only zero's
corr_1 %>% ggcorrplot(hc.order = TRUE, title = "Diagonal Matrix")

#---------------------------------------------
# Correlation matrix with no clusters
#---------------------------------------------
corr_2 <- gen_corr(D = 50, clusters = "none")
eigen_2 <- eigen(corr_2)
corr_2 %>% ggcorrplot(title = "No Clusters")
0.9^(5-1)
#---------------------------------------------
# Correlation matrix with 5 clusters
#---------------------------------------------
corr_3 <- gen_corr(D = 50, clusters = "non-overlapping", num_clusters = 5)
eigen_3 <- eigen(corr_3)
corr_3 %>% ggcorrplot(hc.order = TRUE, title = "Five Clusters")

#---------------------------------------------
# Correlation matrix with 10, 5 and 2 overlapping clusters
#---------------------------------------------
corr_4 <- gen_corr(D = 50, clusters = "overlapping", num_clusters = c(10,5,2), num_layers = 3)
eigen_4 <- eigen(corr_4)
corr_4 %>% ggcorrplot(hc.order = TRUE, title = "Overlapping Clusters")

```

### Emperical
https://eur03.safelinks.protection.outlook.com/?url=https%3A%2F%2Frawgit.com%2Fdppalomar%2FcovFactorModel%2Fmaster%2Fvignettes%2FcovFactorModel-vignette.html&data=04%7C01%7C%7C0caeb7ee2beb449dd0af08d8b409e474%7Ca6fa3b030a3c42588433a120dffcd348%7C0%7C0%7C637457302843416665%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C2000&sdata=1aBOrvjRM9Z3wXBR5miFvKfC5eiRpiUx8FH2bVS0FII%3D&reserved=0

```{r emperical corrs}
#-----------------------------------------------
# Some empirical correlation matrices - from S&P500
# See ??corr_mats for info on how dataset was compiled
# First looking at "normal market"
#-----------------------------------------------
corr_5 <- corr_mats$cor_normal[[2]]
eigen_5 <- eigen(corr_5)
corr_5 %>% ggcorrplot(hc.order = TRUE, title = "Normal Market") +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())

#----------------------------------------------
# "stressed market"
#----------------------------------------------
corr_6 <- corr_mats$cor_stressed[[1]]
eigen_6 <- eigen(corr_6)
corr_6 %>% ggcorrplot(hc.order = TRUE, title = "Stressed Market")  +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())

#----------------------------------------------
# "rally market"
#----------------------------------------------
corr_7 <- corr_mats$cor_rally[[1]]
eigen_7 <- eigen(corr_7)
corr_7 %>% ggcorrplot(hc.order = TRUE, title = "Rally Market")  +
    theme_bw() +
  theme(axis.text.x=element_text(angle=90),
        axis.title = element_blank(),
        axis.ticks = element_blank())

```

### Eigan Values

```{r eigens}
#------------------------------------------
# Table of eigenvalues
#------------------------------------------
# First load emprical corr and calc eigen
load("data/emp_corr.rda")
eigen_5 <- eigen(emp_corr)
  
  
eigens <- tibble(corr_1 = eigen_1$values,
                 corr_2 = eigen_2$values,
                 corr_3 = eigen_3$values,
                 corr_4 = eigen_4$values,
                 corr_5 = eigen_5$values) %>% 
  gather(corr, eigen) %>% group_by(corr) %>% 
  mutate(cond_num = max(abs(eigen))/min(abs(eigen))) %>% 
  arrange(corr)


# Printing Eigenvalues in a table
eigen_table <-
eigens %>% select(-cond_num) %>% group_by(corr) %>% 
  mutate(key = 1:n()) %>%  spread(corr, eigen) %>% select(-key) %>% head(n = 10) %>% 
  set_names(c("Diagonal", "No Clusters", "Five Clusters", "Overlapping Clusters", "Emperical"))
save(eigen_table, file = "data/eigen_table.rda")

rm(eigen_1, eigen_2, eigen_3, eigen_4, eigen_5, eigen_6, eigen_7, eigen_table, corr_6, corr_7, eigens, emp_corr)
```


## Monte Carlo

```{r monte carlo, eval=FALSE, include=TRUE}
# loading packages
pacman::p_load(dplyr, purrr, MCmarket)

# Creating vectors for portfolio mean and sd's
load("data/emp_mu.rda")
load("data/emp_sd.rda")

# Setting number of markets and length of progress bar.
N <- 10000
pb <- dplyr::progress_estimated(N)

#clearing memory and Viewing current limit
gc()

set.seed(9543712)
market <- 
    1:N %>%
    map(~sim_market_with_progress(corr = corr_1,
                                  k = 300,
                                  mv_dist = "t",
                                  mv_df = 3,
                                  marginal_dist = "norm",
                                  marginal_dist_model = list(mu = emp_mu,
                                                                 sd = emp_sd),
                                  ts_model = NULL)) 
gc()
```

```{r saving mcdata, eval=FALSE, include=TRUE}
# Saving dataframe
save(market_1, file = "data/market_1.rda")
rm(market_1)
gc()
```

## Portfolio Optimisation

### Functions: Portfolios with Periodic Rebalancing 

```{r}
pacman::p_load(lubridate, fitHeavyTail, RiskPortfolios, tbl2xts, rmsfuns, tictoc)
# --------------------------------------------------------------------
# This function creates a set of weights from a single market at a date
# --------------------------------------------------------------------
port_weight_calc <- function(data, method = "minvol", from_date, look_back = 100) {
  
  
  if (method != "naive") { 
    cov <- data %>%
            filter(date < from_date & date >= from_date %m-% days(look_back)) %>%
            spread(Asset, Return) %>% select(-date) %>%
            fit_mvt() %>% .$cov
    }
 
    # Calculating min var weights and making xts
    if (method == "naive") {
      weights <- data %>%
        filter(date == from_date) %>%
        mutate(weight = 1 / n()) %>%
        select(date, Asset, weight)
      
    } else
      if (method == "minvol") {
        weights <- data %>%
          filter(date == from_date) %>%
          mutate(weight = optimalPortfolio(
            Sigma = cov,
            control = list(
              type = "minvol",
              constraint = "user",
              LB = rep(0, nrow(cov)),
              UB = rep(0.2, nrow(cov))
            )
          )) %>%
        select(-Return)
        
      } else
        if (method == "invvol") {
          weights <- data %>%
          filter(date == from_date) %>%
          mutate(weight = optimalPortfolio(
            Sigma = cov,
            control = list(
              type = "invvol",
              constraint = "user",
              LB = rep(0, nrow(cov)),
              UB = rep(0.2, nrow(cov))
            )
          )) %>%
        select(-Return)
          
        } else
          if (method == "erc") {
            weights <- data %>%
          filter(date == from_date) %>%
          mutate(weight = optimalPortfolio(
            Sigma = cov,
            control = list(
              type = "erc",
              constraint = "user",
              LB = rep(0, nrow(cov)),
              UB = rep(0.2, nrow(cov))
            )
          )) %>%
        select(-Return)
            
          } else
            if (method == "maxdiv") {
              weights <- data %>%
          filter(date == from_date) %>%
          mutate(weight = optimalPortfolio(
            Sigma = cov,
            control = list(
              type = "maxdiv",
              constraint = "user",
              LB = rep(0, nrow(cov)),
              UB = rep(0.2, nrow(cov))
            )
          )) %>%
        select(-Return)
            }

    return(weights)
}

#eg: w <- port_weight_calc(data = dat[[1]], method = "minvol", from_date = as.Date("2021-04-26"), look_back = 100)

# --------------------------------------------------------------
# This function calculates portfolio returns for a single market
# --------------------------------------------------------------
port_returns <- function(data, weights, look_back) {
  
  returns_xts <- data %>% 
    select(date, Asset, Return)%>% 
    spread(Asset, Return) %>% 
    filter(date>=first(date) %m+% days(look_back)) %>% 
    tbl_xts()
  
  weights_xts <- weights %>% 
    spread(Asset, weight) %>% 
    tbl_xts()
  
   # Calculating portfolio returns
  rmsfuns::Safe_Return.portfolio(returns_xts, weights = weights_xts) %>% 
    xts_tbl()
    
}

#eg: port_returns(data = dat[[1]], weights = w, look_back = 100)

# -----------------------------------------------------------------------------
# This function couples the first two functions in this chunk.
# Therefore, it creates portfolio returns with periodic re-balancing.
# ----------------------------------------------------------------------------
rebal_port_returns <- function(data, method, rebdates, look_back) {
  
  pb$tick()$print()
  
  weights <- rebdates %>%
  map_dfr(~port_weight_calc(data, method = method, 
                            from_date =  .x, 
                            look_back = look_back))

port_returns(data, weights = weights, look_back = look_back)
}

#eg. rebal_port_returns(dat[[1]], method = "minvol", rebdates, look_back = 100)

# ----------------------------------------------------------------------------
# This function maps rebal_port_returns over the Universe columns of the dataset
# Therefore, it creates portfolio returns with periodic re-balancing, for each universe
# ----------------------------------------------------------------------------
port_rets_universal <- function(data_universal, method, rebdates, look_back = 100) {
  # Tick to progress bar
  
  data_universal  %>% map(~rebal_port_returns(.x, 
                                   method = method, 
                                   rebdates = rebdates, 
                                   look_back = look_back))
  
}
 
```

## Calculating Portfolio Returns

### Market 1

```{r, eval=FALSE, include=TRUE}
# Load MC data
load("data/market_1.rda")
pacman::p_load(tidyverse, lubridate, fitHeavyTail, RiskPortfolios, tbl2xts, rmsfuns)

source("code/calc_port_returns.R")
# dat <- market_1[[1]]
# dat <- market_1[1:2]

# Vector of rebalance dates
# Only works for k=300 and look_back = 100
rebdates <- c(first(market_1[[1]]$date) %m+% days(100), 
              first(market_1[[1]]$date) %m+% days(150),
              first(market_1[[1]]$date) %m+% days(200),
              first(market_1[[1]]$date) %m+% days(250))

# Testing:: port_rets_universal(dat, method = "naive", rebdates, look_back = 100)

methods <- c("naive", "minvol", "invvol", "erc", "maxdiv")

#=====================================
# Calculating portfolio returns, 
# for each portfolio type in market 1.
#====================================
N <- 10000

pb <- dplyr::progress_estimated(N)
naive_m1 <- port_rets_universal(market_1, method = "naive", rebdates, look_back = 100)
save(naive_m1, file = "data/naive_m1.rda")
rm(naive_m1)

pb <- dplyr::progress_estimated(N)
minvol_m1 <- port_rets_universal(market_1, method = "minvol", rebdates, look_back = 100)
save(minvol_m1, file = "data/minvol_m1.rda")
rm(minvol_m1)

pb <- dplyr::progress_estimated(N)
invvol_m1 <- port_rets_universal(market_1, method = "invvol", rebdates, look_back = 100)
save(invvol_m1, file = "data/invvol_m1.rda")
rm(invvol_m1)

pb <- dplyr::progress_estimated(N)
erc_m1 <- port_rets_universal(market_1, method = "erc", rebdates, look_back = 100)
save(erc_m1, file = "data/erc_m1.rda")
rm(erc_m1)

pb <- dplyr::progress_estimated(N)
maxdiv_m1 <- port_rets_universal(market_1, method = "maxdiv", rebdates, look_back = 100)
save(maxdiv_m1, file = "data/maxdiv_m1.rda")
rm(maxdiv_m1)

# load("data/naive_m1.rda")
# load("data/minvol_m1.rda")
# load("data/invvol_m1.rda")
# load("data/erc_m1.rda")
# load("data/maxdiv_m1.rda")
# rets_m1 <- list(naive_m1, minvol_m1, invvol_m1, erc_m1, maxdiv_m1)
# names(rets_m1) <- methods
# save(rets_m1, file = "data/rets_m1.rda")

rm(market_1)
gc()

#====================================
# for each portfolio type in market 2.
#====================================
load("data/market_2.rda")

N <- 10000

pb <- dplyr::progress_estimated(N)
naive_m2 <- port_rets_universal(market_2, method = "naive", rebdates, look_back = 100)
save(naive_m2, file = "data/naive_m2.rda")
rm(naive_m2)

pb <- dplyr::progress_estimated(N)
minvol_m2 <- port_rets_universal(market_2, method = "minvol", rebdates, look_back = 100)
save(minvol_m2, file = "data/minvol_m2.rda")
rm(minvol_m2)

pb <- dplyr::progress_estimated(N)
invvol_m2 <- port_rets_universal(market_2, method = "invvol", rebdates, look_back = 100)
save(invvol_m2, file = "data/invvol_m2.rda")
rm(invvol_m2)

pb <- dplyr::progress_estimated(N)
erc_m2 <- port_rets_universal(market_2, method = "erc", rebdates, look_back = 100)
save(erc_m2, file = "data/erc_m2.rda")
rm(erc_m2)

pb <- dplyr::progress_estimated(N)
maxdiv_m2 <- port_rets_universal(market_2, method = "maxdiv", rebdates, look_back = 100)
save(maxdiv_m2, file = "data/maxdiv_m2.rda")
rm(maxdiv_m2)

# load("data/naive_m2.rda")
# load("data/minvol_m2.rda")
# load("data/invvol_m2.rda")
# load("data/erc_m2.rda")
# load("data/maxdiv_m2.rda")
# rets_m2 <- list(naive_m2, minvol_m2, invvol_m2, erc_m2, maxdiv_m2)
# names(rets_m2) <- methods
# save(rets_m2, file = "data/rets_m2.rda")

rm(market_2)
gc()
#====================================
# for each portfolio type in market 3.
#====================================
load("data/market_3.rda")

N <- 10000

pb <- dplyr::progress_estimated(N)
naive_m3 <- port_rets_universal(market_3, method = "naive", rebdates, look_back = 100)
save(naive_m3, file = "data/naive_m3.rda")
rm(naive_m3)

pb <- dplyr::progress_estimated(N)
minvol_m3 <- port_rets_universal(market_3, method = "minvol", rebdates, look_back = 100)
save(minvol_m3, file = "data/minvol_m3.rda")
rm(minvol_m3)

pb <- dplyr::progress_estimated(N)
invvol_m3 <- port_rets_universal(market_3, method = "invvol", rebdates, look_back = 100)
save(invvol_m3, file = "data/invvol_m3.rda")
rm(invvol_m3)

pb <- dplyr::progress_estimated(N)
erc_m3 <- port_rets_universal(market_3, method = "erc", rebdates, look_back = 100)
save(erc_m3, file = "data/erc_m3.rda")
rm(erc_m3)

pb <- dplyr::progress_estimated(N)
maxdiv_m3 <- port_rets_universal(market_3, method = "maxdiv", rebdates, look_back = 100)
save(maxdiv_m3, file = "data/maxdiv_m3.rda")
rm(maxdiv_m3)

rm(market_3)
gc()

#====================================
# for each portfolio type in market 4.
#====================================
load("data/market_4.rda")

N <- 10000

pb <- dplyr::progress_estimated(N)
naive_m4 <- port_rets_universal(market_4, method = "naive", rebdates, look_back = 100)
save(naive_m4, file = "data/naive_m4.rda")
rm(naive_m4)

pb <- dplyr::progress_estimated(N)
minvol_m4 <- port_rets_universal(market_4, method = "minvol", rebdates, look_back = 100)
save(minvol_m4, file = "data/minvol_m4.rda")
rm(minvol_m4)

pb <- dplyr::progress_estimated(N)
invvol_m4 <- port_rets_universal(market_4, method = "invvol", rebdates, look_back = 100)
save(invvol_m4, file = "data/invvol_m4.rda")
rm(invvol_m4)

pb <- dplyr::progress_estimated(N)
erc_m4 <- port_rets_universal(market_4, method = "erc", rebdates, look_back = 100)
save(erc_m4, file = "data/erc_m4.rda")
rm(erc_m4)

pb <- dplyr::progress_estimated(N)
maxdiv_m4 <- port_rets_universal(market_4, method = "maxdiv", rebdates, look_back = 100)
save(maxdiv_m4, file = "data/maxdiv_m4.rda")
rm(maxdiv_m4)

rm(market_4)
gc()

#====================================
# for each portfolio type in market 5
#====================================
load("data/market_5.rda")

N <- 10000

pb <- dplyr::progress_estimated(N)
naive_m5 <- port_rets_universal(market_5, method = "naive", rebdates, look_back = 100)
save(naive_m5, file = "data/naive_m5.rda")
rm(naive_m5)

pb <- dplyr::progress_estimated(N)
minvol_m5 <- port_rets_universal(market_5, method = "minvol", rebdates, look_back = 100)
save(minvol_m5, file = "data/minvol_m5.rda")
rm(minvol_m5)

pb <- dplyr::progress_estimated(N)
invvol_m5 <- port_rets_universal(market_5, method = "invvol", rebdates, look_back = 100)
save(invvol_m5, file = "data/invvol_m5.rda")
rm(invvol_m5)

pb <- dplyr::progress_estimated(N)
erc_m5 <- port_rets_universal(market_5, method = "erc", rebdates, look_back = 100)
save(erc_m5, file = "data/erc_m5.rda")
rm(erc_m5)

pb <- dplyr::progress_estimated(N)
maxdiv_m5 <- port_rets_universal(market_5, method = "maxdiv", rebdates, look_back = 100)
save(maxdiv_m5, file = "data/maxdiv_m5.rda")
rm(maxdiv_m5)

rm(market_5, rets_m5)

gc()

```

## Portfolio Analytics
This function calculated various portfilio metrics for a list of portfolio returns

```{r portfolio metrics}


get_perf_metrics <- function(port_ret_data) {
  
  Sharp <- 
  port_ret_data %>% map( ~ SharpeRatio(tbl_xts(.), FUN = "StdDev") %>%
                           as_tibble()) %>% 
    reduce(bind_rows) %>% set_names("sharp")
  
  SD <-
    port_ret_data %>% map(~ sd(.$portfolio.returns) %>% 
                   as_tibble()) %>% 
    reduce(bind_rows) %>% set_names("sd")
  
  DD <- port_ret_data %>% map( ~ DownsideDeviation(.$portfolio.returns) %>% 
                                 as_tibble) %>% 
    reduce(bind_rows) %>% set_names("dd") 
  
  VaR <- port_ret_data %>% map( ~ VaR(tbl_xts(.)) %>% 
                                  as_tibble()) %>% 
    reduce(bind_rows) %>% set_names("Var") 
  
  list(Sharp = Sharp, SD = SD, DD = DD, Var = VaR)
  
}
```


### Market 1
```{r}
load("data/rets_m1.rda")
pacman::p_load(PerformanceAnalytics)

#===================
# Naive Portfolio
#==================

naive_perf_m1 <- get_perf_metrics(rets_m1$naive)
minvol_perf_m1 <- get_perf_metrics(rets_m1$minvol)
invvol_perf_m1 <- get_perf_metrics(rets_m1$invvol)
erc_perf_m1 <- get_perf_metrics(rets_m1$erc)
maxdiv_perf_m1 <- get_perf_metrics(rets_m1$maxdiv)
perf_m1 <- list(naive = naive_perf_m1,
                minvol = minvol_perf_m1,
                invvol = invvol_perf_m1,
                erc = erc_perf_m1,
                maxdiv = maxdiv_perf_m1)
save(perf_m1, file = "data/perf_m1.rda")
rm(naive_perf_m1, minvol_perf_m1, invvol_perf_m1, erc_perf_m1, maxdiv_perf_m1)

# perf_m1$naive$Sharp[[1]] %>% mean()
# perf_m1$minvol$Sharp[[1]] %>% mean()
# perf_m1$invvol$Sharp[[1]] %>% mean()
# perf_m1$erc$Sharp[[1]] %>% mean()
# perf_m1$maxdiv$Sharp[[1]] %>% mean()

# perf_m1$naive$SD[[1]] %>% mean()
# perf_m1$minvol$SD[[1]] %>% mean()
# perf_m1$invvol$SD[[1]] %>% mean()
# perf_m1$erc$SD[[1]] %>% mean()
# perf_m1$maxdiv$SD[[1]] %>% mean()

# perf_m1$naive$DD[[1]] %>% mean()
# perf_m1$minvol$DD[[1]] %>% mean()
# perf_m1$invvol$DD[[1]] %>% mean()
# perf_m1$erc$DD[[1]] %>% mean()
# perf_m1$maxdiv$DD[[1]] %>% mean()

# perf_m1$naive$Var[[1]] %>% na.omit() %>% mean()     # 3 NA's
# perf_m1$minvol$Var[[1]] %>% mean()
# perf_m1$invvol$Var[[1]] %>% na.omit() %>% mean()  # 1 NA
# perf_m1$erc$Var[[1]] %>% na.omit() %>% mean()   # 1 Na
# perf_m1$maxdiv$Var[[1]] %>% mean()

```

### Market 2

```{r RiskPortfolios, warning=FALSE}
pacman::p_load(PerformanceAnalytics)
universal_portfolio_analytics <- function(portfolio_return_tbl,
                                          method) {
  
  if(!method %in% c("sd", "DownsideDeviation", 
                    "VaR", "CVaR", "SharpRatio", 
                    "AverageDrawdown", "maxDrawdown")) stop("Please Provide a valid method argument")
    xts_list <-
    portfolio_return_tbl %>% 
    split(portfolio_return_tbl$Universe) %>% 
    map(~select(.data = .x, date, portfolio.returns)) %>% 
    map(~tbl_xts(.x)) 
  
  case_when(
    method == "sd" ~ map(xts_list, ~sd(.x)),
    method == "DownsideDeviation" ~ map(xts_list, ~DownsideDeviation(.x)),
    method == "VaR" ~ map(xts_list, ~VaR(.x)),
    method == "CVaR" ~ map(xts_list, ~CVaR(.x)),
    method == "SharpRatio" ~ map(xts_list, ~SharpeRatio(.x)),
    method == "AverageDrawdown" ~ map(xts_list, ~AverageDrawdown(.x)),
    method == "maxDrawdown" ~ map(xts_list, ~maxDrawdown(.x))
  ) %>% 
  map_dfr(~as_tibble(t(.x))) 
}

# Other candidates|| What to use as index??
PerformanceAnalytics::SortinoRatio()
PerformanceAnalytics::InformationRatio()


list_all_portfolio_analytics <- function(portfolio_return_tbl) {
  list(
  StandardDeviation = universal_portfolio_analytics(portfolio_return_tbl, method = "sd"),
  DownsideDeviation = universal_portfolio_analytics(portfolio_return_tbl, method = "DownsideDeviation"), 
  VaR = universal_portfolio_analytics(portfolio_return_tbl, method = "VaR"), 
  CVaR = universal_portfolio_analytics(portfolio_return_tbl, method = "CVaR"), 
  SharpRatio = universal_portfolio_analytics(portfolio_return_tbl, method = "SharpRatio"),
  AverageDrawdown = universal_portfolio_analytics(portfolio_return_tbl, method = "AverageDrawdown"),
  maxDrawdown = universal_portfolio_analytics(portfolio_return_tbl, method = "maxDrawdown")
)
}

# All Portfolio analytics for each portfolio type
# naive_portfolio_analytics <- list_all_portfolio_analytics(naive_port_m1)
# min_var_portfolio_analytics <- list_all_portfolio_analytics(min_var_port_m1)
# invvol_portfolio_analytics <- list_all_portfolio_analytics(invvol_port_m1)
# erc_portfolio_analytics <- list_all_portfolio_analytics(erc_port_m1)
# maxdiv_portfolio_analytics <- list_all_portfolio_analytics(maxdiv_port_m1)

port_analytics <- list(
  StandardDeviation = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "sd"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "sd"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "sd"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "sd"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "sd")
           ),
  DownsideDeviation = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "DownsideDeviation"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "DownsideDeviation"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "DownsideDeviation"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "DownsideDeviation"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "DownsideDeviation")
  ),
  VaR = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "VaR"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "VaR"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "VaR"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "VaR"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "VaR")
  ),
  CVaR = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "CVaR"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "CVaR"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "CVaR"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "CVaR"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "CVaR")
  ),
  SharpRatio = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "SharpRatio"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "SharpRatio"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "SharpRatio"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "SharpRatio"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "SharpRatio")
  ),
  AverageDrawdown = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "AverageDrawdown"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "AverageDrawdown"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "AverageDrawdown"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "AverageDrawdown"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "AverageDrawdown")
  ),
  maxDrawdown = tibble(
    naive_portfolio = universal_portfolio_analytics(naive_port_m1, method = "maxDrawdown"),
    min_var_portfolio = universal_portfolio_analytics(min_var_port_m1, method = "maxDrawdown"),
    invvol_portfolio = universal_portfolio_analytics(invvol_port_m1, method = "maxDrawdown"),
    erc_portfolio = universal_portfolio_analytics(erc_port_m1, method = "maxDrawdown"),
    maxdiv_portfolio = universal_portfolio_analytics(maxdiv_port_m1, method = "maxDrawdown")
  )
)


```




# Apendix


### Calculating Expected returns and Covarience matricies.

```{r portfoio optimisers, eval=FALSE, include=TRUE}
pacman::p_load(lubridate, RiskPortfolios, fitHeavyTail)
load("data/market_1.rda")

# selecting only one market
data <- market_1 %>% 
  filter(Universe == 1) %>% 
  select(date, Asset, Return) %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date<first(date) %m+% days(100)) # only first 100 days
rm(market_1); gc()

data_no_date <- data %>% select(-date) %>% data.matrix()

# Simple covariance matrix: Assuming Gaussian (when we know actually t)
cov <- RiskPortfolios::covEstimation(data_no_date)
# Ledoit Wolf shrinkage:
cov_lw <- RiskPortfolios::covEstimation(data_no_date, control = list(type = "lw"))
# Shrinkage using constant correlation matrix:
cov_const <- RiskPortfolios::covEstimation(data_no_date, control = list(type = "const"))
# FitHeavyTail method
HTT <- fitHeavyTail::fit_mvt(data_no_date)
mu_ht <- HTT$mu
cov_ht <- HTT$cov

cov %>% cov2cor() %>% ggcorrplot()
cov_lw %>% cov2cor() %>% ggcorrplot()
cov_const %>% cov2cor() %>% ggcorrplot() # this seems junk
cov_ht %>% cov2cor() %>% ggcorrplot()

Mu <- data %>%
  select(-date) %>% 
  data.matrix() %>% 
  RiskPortfolios::meanEstimation()

```

### Setting Constraints 


### Calculating Some Portfolio Optimiser Weights 
```{r Min Var, eval=FALSE, include=TRUE}
pacman::p_load(quadprog, tbl2xts, RiskPortfolios)

minvar(var = cov_ht, wmin = 0.0, wmax = 1)
Sigma <- MCmarket::corr_mats$cor_normal[[1]]

optimalPortfolio(Sigma, 
                 control = list(type = "minvol", constraint = "user", LB = rep(0, nrow(Sigma)), UB = rep(0.2, nrow(Sigma))))

optimalPortfolio(Sigma = cov_ht, 
                 control = list(type = "invvol", constraint = "lo"))

optimalPortfolio(Sigma = cov_ht, 
                 control = list(type = "erc", constraint = "lo"))

optimalPortfolio(Sigma = cov_ht, 
                 control = list(type = "maxdiv", constraint = "lo"))

```

#### Nieve 1/N Portfilio Returns

#### Min Var Portfolio Returns

```{r, eval=FALSE, include=TRUE}
load("data/market_1.rda")

# Creating a single market dataset
data <- market_1 %>% 
  filter(Universe == 1) %>% 
  select(date, Asset, Return)  
rm(market_1)

# Creating a wide exante data set
data_exante <- data %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date<first(date) %m+% days(100))

# Calculating covarience matrix
cov <- data_exante %>% 
  select(-date) %>% 
  fit_mvt() %>% .$cov

# Calculating min var weights and making xts 
weights <- 
  data %>% 
  filter(date == first(date)) %>% 
  mutate(weight = minvar(cov, wmin = 0, wmax = 1)) %>% 
  select(date, Asset, weight) %>% 
  tbl_xts(cols_to_xts = "weight", spread_by = "Asset")

# Creating expost portfolio dataset
data_expost_xts <- data %>%
  spread(Asset, Return) %>% 
  arrange(date) %>% 
  filter(date>first(date) %m+% days(100)) %>% 
  tbl_xts()


rmsfuns::Safe_Return.portfolio(data_expost_xts, weights = weights)
  
```



